#!/usr/bin/env node
'use strict';

// Core dependencies
var path = require('path');
var fs = require('fs');

// npm dependencies
var glob = require('glob');
var program  = require('commander');
var pkgDir = require('pkg-dir');

// Project dependencies
var I18nLint = require('../');

// Local variables
var completed = 0;
var failed = false;
var options = {};
var pkg = require('../package.json');
var reporter;
var stdin = '';
var stdinTimeout;
var toScan = new Set();
var initializeConfig = false;
var configFileName = '.i18n-lint.json';

program.on('--help', function() {
  process.stdout.write('  Use `man i18n-lint` for more information\n\n');
});

program
  .version(pkg.version)
  .option(
    '-a, --attributes <attributes>',
    'Comma-separated list of HTML attributes to lint (default: \'alt,title,placeholder\')',
    function(raw) {
      return raw.split(',');
    }
  )
  .option(
    '-i, --ignore-tags <tags>',
    'Comma-separated list of names of tags to ignore whilst linting '+
        '(default: \'script,style\')',
    function(raw) {
      return raw.split(',');
    }
  )
  .option(
    '-t, --template-delimiters <delimiters>',
    'Template delimiters used in source files.  For example, Mustache-like ' +
        'templating languages should use \'{{,}}\'',
    function(raw, accu) {
      accu.push(raw.split(','));
      return accu;
    },
    []
  )
  .option(
    '-r, --reporter <reporter>',
    'Specify which reporter to output results with'
  )
  .option(
    '--exclude <exclusion patterns>', 'Comma-separated list of glob patterns to ignore, '+
      ' e.g. "/test_subdir/,ignored.html"',
      function(raw) {
        return raw.split(',');
      },
      []
  )
  .option(
    '--color', 'Force colored output'
  )
  .option(
    '--no-color', 'Disable colored output'
  )
  .option(
    '--init', 'Generate configuration file'
  )
  .option(
    '-c, --config <configName>', 'Use this configuration, overriding .i18n-lint.json config options if present', '.i18n-lint.json'
  )
  .usage('[OPTIONS] <file ...>')
  .parse(process.argv)
;

program.options.forEach(function(option) {
  var key = option.long.replace(/^--/, '')
      .replace(/-([a-z])/g, function(orig, match) {
        return match.toUpperCase();
      });

  if (key === 'init' && program[key] == true) {
    initializeConfig = true;
  } else if (key === 'config' && program) {
    configFileName = program[key];
  } else {
    options[key] = program[key];
  }
});

program.args.forEach(function(arg) {
  if (arg === '-') {
    return;
  }
  if (options.exclude.some(function(pattern) {
    return arg.indexOf(pattern) !== -1;
  })) {
    return;
  }
  toScan.add(arg);
});

var configFullPath = path.join(pkgDir.sync(), configFileName);

if (initializeConfig) {

  // generate a configuration file
  if (fs.existsSync(configFullPath)) {
    process.stderr.write('Configuration file already exists at ' + configFileName + '!\nPlease remove it if you want to generate a new one.\n');
    process.exit(51);
  } else {

    // first set default values for parameters that were not provided in the CLI
    if (!options.attributes) {
      options.attributes = ['alt', 'placeholder', 'title'];
    }
    if (!options.ignoreTags) {
      options.ignoreTags = ['style', 'script', 'pre', 'code'];
    }
    if (!options.templateDelimiters || (Array.isArray(options.templateDelimiters) && !options.templateDelimiters.length)) {
      options.templateDelimiters = [['{', '}']];
    }
    if (!toScan.size) {
      options.include = [ '**/*.html' ];
    } else {
      options.include = Array.from(toScan);
    }
    var data = JSON.stringify(options, undefined, 2);

    try {
      fs.writeFileSync(configFullPath, data);
    } catch (ex) {
      process.stderr.write('Error creating configuration file at ' + configFileName + '!\n' + ex + '\n');
      process.exit(52);
    }
    process.stdout.write('Configuration data is saved to ' + configFullPath + '\n');
    process.exit(0);
  }
} else {

  // read configuration form the file (if exists), add any unset options (don't overwrite options specified in CLI)
  if (fs.existsSync(configFullPath)) {
    process.stdout.write('Reading configuration from ' + configFullPath + '\n');
    var rawData = fs.readFileSync(configFullPath);
    var jsonData = JSON.parse(rawData);  
    Object.keys(jsonData).forEach(function(key) {
        var value = jsonData[key];
        if (!options[key] || (Array.isArray(options[key]) && !options[key].length)) {
          options[key] = value;
        }
    });
  }
}

if (options.reporter) {

  // Check built-in i18n-lint reporters first
  reporter = I18nLint.reporters[options.reporter];

  if (!reporter) {
    try {
      reporter = require(path.resolve(options.reporter));
    } catch(e) {
      process.stderr.write('No reporter called \'' + options.reporter + '\'\n');
      process.exit(66);
    }
  }
} else {
  reporter = I18nLint.reporters.default;
}

delete options.reporter;

if (!program.args.length || program.args[0] === '-') {

  // @todo pass stream directly to i18n-lint once streaming implemented
  process.stdin.setEncoding('utf8');

  process.stdin.on('readable', function() {
    clearTimeout(stdinTimeout);
    var chunk = process.stdin.read();
    if (chunk !== null) {
      stdin += chunk;
    }
  });

  process.stdin.on('end', function() {
    if (!stdin) {
      return;
    }

    var errors = I18nLint.scan(stdin, options).map(function(err) {
      return {
        file: 'stdin',
        error: err
      };
    });

    reporter(errors);

    if (errors.length) {
      return process.exit(1);
    }

    process.exit(0);
  });

  if (!program.args.length) {
    if (options.include) {
      options.include.forEach(function(option) { toScan.add(option); });
    } else {
      return (stdinTimeout = setTimeout(function() {
        process.stdout.write('No files specified. See \'i18n-lint --help\':\n');
        program.outputHelp();
        process.exit(64);
      }, 10));
    }
  }
}

try {
  toScan.forEach(function(src) {    
    var files = glob.sync(src, {ignore: options.exclude});    
    
    if (!files.length) {
      process.stderr.write('i18n-lint: ' + src + ': No such file or directory\n');
      process.exit(66);
    }

    files.forEach(function(file) {
      try {
        var errors = I18nLint(file, options).map(function(err) {
          return {
            file: file,
            error: err
          };
        });

        reporter(errors);

        if (errors.length) {
          failed = true;
        }
      } catch(e) {
        failed = true;

        if (e.code === 'EISDIR') {
          process.stderr.write('i18n-lint: ' + file + ': is a directory\n');
          process.exit(64);
        } else {
          process.stderr.write(e);
          process.exit(70);
        }
      }
    });
    completed++;

    if (completed === toScan.size) {
      if (failed) {
        return process.exit(1);
      }

      process.exit(0);
    }
  });
} catch (ex) {
  process.stderr.write(ex);
  process.exit(70);
}
